```{r lib}
library(tidyverse)
library(validate)
library(readr)
library(dplyr)
library(naniar)
library(finalfit)
library(mice)
library(ggplot2)
library(kableExtra)
library(summarytools)
library(ggridges)
library(gtsummary)
library(frequency)
library(corrplot)
library(ggpubr)
library(skimr)
library(leaflet)
library(leaflet.extras)
library(tidyr)
library(gt)
```

SPRAWDZANIE CZY SA DUPLICATY, FILTRACJA DANYCH PO MIASTU

```{r wstep}
dane<-read_csv("apartments_pl_2024_06.csv")
dane<-filter(dane, city=="gdansk")
sum(duplicated(dane))#  brak duplikatów-> mozna usunąć kolumne id i iine nie potrzebne kolumny
# takie wstępne przygotowanie danych
dane_gdansk <- dane %>%
  select(-c(id, condition, buildingMaterial,city))%>%
  mutate(across(where(is.character),as.factor))%>%
  mutate(price_m2 = price / squareMeters)
# slowniki do etykietowania zmiennych 
var_labels <- c(
  type = "Typ budynku",
  squareMeters = "Powierzchnia mieszkania [m²]",
  rooms = "Liczba pokoi",
  floor = "Piętro",
  floorCount = "Liczba kondygnacji w budynku",
  buildYear = "Rok budowy",
  latitude = "Szerokość geograficzna",
  longitude = "Długość geograficzna",
  centreDistance = "Odległość od centrum [km]",
  poiCount = "Liczba punktów POI w pobliżu",
  schoolDistance = "Odległość do szkoły [km]",
  clinicDistance = "Odległość do przychodni [km]",
  postOfficeDistance = "Odległość do poczty [km]",
  kindergartenDistance = "Odległość do przedszkola [km]",
  restaurantDistance = "Odległość do restauracji [km]",
  collegeDistance = "Odległość do uczelni [km]",
  pharmacyDistance = "Odległość do apteki [km]",
  ownership = "Forma własności",
  hasParkingSpace = "Miejsce parkingowe",
  hasBalcony = "Balkon",
  hasElevator = "Winda",
  hasSecurity = "Ochrona",
  hasStorageRoom = "Komórka lokatorska",
  price = "Cena całkowita [PLN]",
  price_m2 = "Cena za metr kwadratowy [PLN/m²]"
)
var_labels <- as.list(var_labels)
label_vars <- function(x) {recode(x, !!!var_labels)}

# mapa mieszka -> NIE WIEM W KTÓRYM MOMENCIE NAJLEPIEJ JĄ DODAĆ
leaflet(dane_gdansk) |>
  addTiles() |>
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = 3,
    stroke = FALSE,
    fillOpacity = 0.4
  )
```

#### **Hipoteza główna (H):**

Apartamenty o większym metrażu osiągają wyższe ceny całkowite, ale mieszkania o mniejszym metrażu mają wyższe ceny za metr kwadratowy.

Metraż mieszkania istotnie różnicuje poziom cen na rynku nieruchomości, zarówno w ujęciu ceny całkowitej, jak i ceny za metr kwadratowy.

sPRAWDZANIE NA NIE SPÓJNOŚCI DANYCH I BLEDOW LOGICZNYCH Wyniki walidacji reguł twardych nie wykazały żadnych naruszeń spójności logicznej ani dziedzinowej. W związku z brakiem przypadków niespełniających przyjętych warunków, szczegółowe zestawienie tabelaryczne reguł walidacyjnych pominięto, ograniczając prezentację do opisu procedury. Przed imputacją przeprowadzono walidację twardą i miękką regułami logicznymi/dziedzinowymi. Walidacja twarda nie wykazała naruszeń. Reguły miękkie wykazały jedynie przypadki nietypowe, które pozostawiono w zbiorze jako obserwacje potencjalnie realistyczne. W konsekwencji zbiór uznano za spójny do dalszych etapów analizy

```{r walid}
# sprawdzanie występowania braków danych, żeby wiedzieć gdzie w regułach musimy dopuśćić wystapowanie NA
miss_var_summary(dane_gdansk)
# reguly: dla zmiennych, w których nie występowały braki danych, nie uwzględniano warunku is.na(). Dla pozostałych zmiennych braki danych pozostawiono i traktowano jako dopuszczalne
rules_hard <- validator(

  squareMeters > 0,
  squareMeters <= 250,

  rooms >= 1,
  rooms <= 8,         

  squareMeters >= rooms * 8,      
  squareMeters <= rooms * 40,     

  floor >= 0 | is.na(floor),     
  floorCount >= 1 | is.na(floorCount),
  floor <= floorCount | is.na(floor) | is.na(floorCount),

  buildYear >= 1850 | is.na(buildYear),
  buildYear <= 2025 | is.na(buildYear),
  
  centreDistance >= 0,
  schoolDistance >= 0 | is.na(schoolDistance),
  clinicDistance >= 0 | is.na(clinicDistance),
  postOfficeDistance >= 0 | is.na(postOfficeDistance),
  kindergartenDistance >= 0 | is.na(kindergartenDistance),
  restaurantDistance >= 0 | is.na(restaurantDistance),
  collegeDistance >= 0 | is.na(collegeDistance),
  pharmacyDistance >= 0 | is.na(pharmacyDistance),

  centreDistance <= 20,
  schoolDistance <= 10 | is.na(schoolDistance),
  clinicDistance <= 10 | is.na(clinicDistance),
  postOfficeDistance <= 10 | is.na(postOfficeDistance),
  kindergartenDistance <= 10 | is.na(kindergartenDistance),
  restaurantDistance <= 10 | is.na(restaurantDistance),
  collegeDistance <= 15 | is.na(collegeDistance),
  pharmacyDistance <= 10 | is.na(pharmacyDistance),

  poiCount >= 0,
  poiCount <= 300,               

  type %in% c("tenement","blockOfFlats","apartmentBuilding") | is.na(type),
  ownership %in% c("condominium","cooperative"),

  hasParkingSpace %in% c("yes","no"),
  hasBalcony %in% c("yes","no"),
  hasElevator %in% c("yes","no") | is.na(hasElevator),
  hasSecurity %in% c("yes","no"),
  hasStorageRoom %in% c("yes","no"),

  price > 0,
  price / squareMeters >= 8000,
  price / squareMeters <= 35000
)
out_hard <- confront(dane_gdansk, rules_hard)
summary(out_hard)
out <- confront(dane_gdansk, rules_hard)
summary(out)
summary(out_hard)$fails

rules_soft <- validator(

  !(buildYear < 1945 & floorCount > 7) | is.na(buildYear) | is.na(floorCount),
  !(floor >= 5 & buildYear >= 1995 & hasElevator == "no") | is.na(floor) | is.na(buildYear) | is.na(hasElevator),
  !(squareMeters < 35 & rooms >= 3),
  !(squareMeters > 80 & rooms == 1)
)
out_soft <- confront(dane_gdansk, rules_soft)
summary(out_soft)
summary(out_soft)$fails


# Dla zmiennych, w których nie występowały braki danych, nie uwzględniano warunku is.na(). Dla pozostałych zmiennych braki danych pozostawiono i traktowano jako dopuszczalne
```

dentyfikacja outlierów metodą IQR

```{r iqr}
# wybór zmiennych numerycznych
num_vars <- dane_gdansk %>% select(where(is.numeric))

iqr_outliers <- num_vars %>%
  summarise(across(
    everything(),
    ~ {
      q1 <- quantile(.x, 0.25, na.rm = TRUE)
      q3 <- quantile(.x, 0.75, na.rm = TRUE)
      iqr <- IQR(.x, na.rm = TRUE)
      mean(.x < (q1 - 1.5 * iqr) | .x > (q3 + 1.5 * iqr), na.rm = TRUE) * 100})) %>%
  pivot_longer(
    everything(),
    names_to = "variable",
    values_to = "pct_outliers") %>%
  arrange(desc(pct_outliers))

kable(iqr_outliers %>%
        mutate(variable = label_vars(variable))%>%
        mutate(pct_outliers = round(pct_outliers, 2)) %>%
        filter(pct_outliers!= 0),
      format = "html", digits = 2,caption = "Identyfikacja wartości odstających (IQR)",col.names = c("Zmienna", "% obserwacji odstających")) %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```

2.1 Braki danych W celu określenia mechanizmu braków danych przeprowadzono test Little MCAR. Wynik testu był istotny statystycznie (χ² = 2374.25, df = 569, p \< 0.001), co pozwala odrzucić hipotezę o całkowicie losowym charakterze braków (MCAR). Oznacza to, że zmienne w zbiorze zawierają braki zależne od innych informacji (MAR) lub od wartości samej zmiennej (MNAR). Braki danych nie mają więc charakteru losowego i wymagają zastosowania zaawansowanej metody imputacji, takiej jak MICE. floor, rokbudowy, czy jest winda, odleglosc od uni Z brakami danych do uzupelnienia. Type i reszta zostaje z brakami danych, bo nie oplaca sie -\> jak to uzasadnić?

mice dla zmiennych numerycznych buduje model liniowy, dla kategorzycznych logitowy

```{r t_NA}
mcar_test(dane_gdansk)
gg_miss_var(dane_gdansk)
vis_miss(dane_gdansk)
gg_miss_upset(dane_gdansk)
missing_pattern(dane_gdansk)
```

W zbiorze danych przeprowadzono analizę braków, której celem było określenie ich zakresu, struktury oraz mechanizmu powstawania. Łączny odsetek braków wyniósł około 3%, jednak nie były one równomiernie rozłożone między zmiennymi. Najwięcej braków odnotowano w zmiennych type, floor oraz buildYear, co wskazuje, że dotyczą one głównie informacji opisujących cechy budynku. Pozostałe zmienne charakteryzowały się znikomym poziomem braków.

Wizualizacje braków, w tym mapy ciepła oraz wykresy typu vis_miss i UpSet Plot, wykazały istnienie wyraźnych wzorców współwystępowania brakujących wartości, co sugeruje, że nie mają one charakteru przypadkowego.

Ze względu na nielosowy charakter braków oraz ich koncentrację w wybranych zmiennych, do uzupełnienia danych zastosowano metodę imputacji wielokrotnej MICE. Metoda ta pozwala odtworzyć brakujące wartości w sposób zgodny z zależnościami występującymi w zbiorze, ograniczając ryzyko zniekształcenia wyników dalszej analizy. Zmienne o minimalnej liczbie braków pozostawiono bez imputacji, gdyż ich wpływ na modele jest pomijalny. Dzięki przeprowadzonej imputacji uzyskano kompletny i spójny zbiór danych, odpowiedni do kolejnych etapów modelowania.

ggmice

```{r imp}
methods <- make.method(dane_gdansk)
methods[] <- ""

methods["floor"]           <- "pmm"
methods["buildYear"]       <- "pmm"
methods["hasElevator"]     <- "logreg"
methods["collegeDistance"] <- "pmm"
methods["type"]            <- ""   

pred <- make.predictorMatrix(dane_gdansk)
pred[,] <- 0
diag(pred) <- 0

pred["floor", c("floorCount","rooms","squareMeters","buildYear","hasElevator","poiCount")] <- 1
pred["buildYear", c("floorCount","centreDistance","poiCount","squareMeters","rooms")] <- 1
pred["hasElevator", c("floorCount","buildYear","floor")] <- 1
pred["collegeDistance", c("centreDistance","poiCount","latitude","longitude")] <- 1
pred[, "type"] <- 0
pred["type", ] <- 0

set.seed(123)
imp <- mice(dane_gdansk, method = methods, predictorMatrix = pred, m = 5, maxit = 20, ridge = 1e-5)
dane_imputed <- complete(imp, 1)

```

srtrip plot dla danych po imputacji

```{r imp_gr}
plot(imp)

densityplot(imp, ~ floor)
densityplot(imp, ~ buildYear)
densityplot(imp, ~ collegeDistance)

# 5) Relacje między zmiennymi (czy imputacja nie psuje logiki)
xyplot(imp, floor ~ floorCount)

# 6) Stripplot (czy imputacje nie „przyklejają się” do jednej wartości)
# Dobry do wykrywania degeneracji imputacji
stripplot(imp, floor ~ .imp, pch = 20, cex = 1)
stripplot(imp, buildYear ~ .imp, pch = 20, cex = 1)
stripplot(imp, collegeDistance ~ .imp, pch = 20, cex = 1)


```

```{r}
```

dane jakosciowe Rozdzial X : analiza opisowa i wizualizacja zmiennych jakościowych Wykresy i statystyki opisowe do świąt

```{r wykresy}
# # metraż a cena
dane_imputed %>%
  mutate(
    size_bin = cut(
      squareMeters,
      breaks = c(0, 30, 50, 70, 90, 120, Inf),
      labels = c("<30","30–50","50–70","70–90","90–120","120+")
    )
  ) %>%
  ggplot(aes(x = size_bin, y = price)) +
  geom_boxplot(fill = "#9ecae1") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Rozkład cen mieszkań według przedziałów metrażu",
    x = "Metraż [m²]",
    y = "Cena [PLN]"
  ) +
  theme_minimal()

dane_imputed %>%
  mutate(
    centre_bin = cut(
      centreDistance,
      breaks = c(0, 1, 3, 5, 8, Inf),
      labels = c("≤1 km","1–3","3–5","5–8",">8")
    )
  ) %>%
  ggplot(aes(x = centre_bin, y = price_m2)) +
  geom_boxplot(fill = "#c7e9c0") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Cena za m² w zależności od odległości od centrum",
    x = "Odległość od centrum",
    y = "Cena za m² [PLN]"
  ) +
  theme_minimal()
dane_imputed %>%
  filter(!is.na(floor), hasElevator %in% c("yes","no"))%>%
  mutate(
    floor_bin = cut(floor, breaks = c(-Inf,1,3,5,10,Inf),
                    labels = c("1","2–3","4–5","6–10","11+"))
  ) %>%
  ggplot(aes(x = floor_bin, y = price_m2, fill = hasElevator)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Znaczenie windy w zależności od piętra",
    x = "Piętro",
    y = "Cena za m² [PLN]",
    fill = "Winda"
  ) +
  theme_minimal()
ggplot(dane_imputed, aes(x = hasBalcony, y = price_m2)) +
  geom_violin(fill = "#9ecae1", alpha = 0.7, trim = TRUE) +
  geom_boxplot(width = 0.1, fill = "white") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Rozkład ceny za m² – balkon vs brak balkonu",
    x = "Balkon",
    y = "Cena za m² [PLN]"
  ) +
  theme_minimal()
###  Różnice cen za m² pomiędzy mieszkaniami z balkonem i bez balkonu są relatywnie niewielkie w porównaniu z innymi czynnikami ### 


# ETU TOCZNO OSZTAWLIAJEM
pal <- colorNumeric("viridis", domain = dane_imputed$price_m2, na.color = "transparent")

leaflet(dane_imputed) %>%
  addProviderTiles("CartoDB.Positron") %>%
  addCircleMarkers(
    lng = ~longitude, lat = ~latitude,
    radius = 3,
    stroke = FALSE,
    fillOpacity = 0.6,
    color = ~pal(price_m2),
    clusterOptions = markerClusterOptions()
  ) %>%
  addLegend("bottomright", pal = pal, values = ~price_m2,
            title = "Cena za m² [PLN]", labFormat = labelFormat())

```

```{r stat, results='asis', echo=FALSE}
cat_vars <- c(
  "type","ownership","hasParkingSpace","hasBalcony",
  "hasElevator","hasSecurity","hasStorageRoom"
)

tab_cat_meta <- dane_imputed %>%
  select(all_of(cat_vars)) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "val") %>%
  group_by(variable) %>%
  summarise(
    liczba_obserwacji = n(),
    liczba_brakow = sum(is.na(val)),
    `%_kompletnosci` = round((1 - liczba_brakow / liczba_obserwacji) * 100, 1),
    liczba_kategorii = n_distinct(val, na.rm = TRUE),
    .groups = "drop"
  )

tab_cat_dist <-dane_imputed %>%
  select(all_of(cat_vars)) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "category") %>%
  filter(!is.na(category)) %>%
  count(variable, category, name = "n") %>%
  group_by(variable) %>%
  mutate(pct = round(n / sum(n) * 100, 1)) %>%
  arrange(variable, desc(n)) %>%
  ungroup()


bin_vars <- c("hasParkingSpace","hasBalcony","hasElevator","hasSecurity","hasStorageRoom")

tab_bin <- dane_imputed %>%
  select(all_of(bin_vars)) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "val") %>%
  mutate(val = tolower(as.character(val))) %>%
  group_by(variable) %>%
  summarise(
    n = n(),
    missing = sum(is.na(val)),
    n_nonmiss = n - missing,
    yes_n = sum(val %in% c("yes","1","true","t"), na.rm = TRUE),
    yes_pct = round(yes_n / n_nonmiss * 100, 1),
    .groups = "drop"
  )

tab_cat_meta <- tab_cat_meta %>% mutate(variable = label_vars(variable))
tab_cat_dist <- tab_cat_dist %>% mutate(variable = label_vars(variable))
tab_cat_top  <- tab_cat_top  %>% mutate(variable = label_vars(variable))
tab_bin      <- tab_bin      %>% mutate(variable = label_vars(variable))

kable(tab_cat_meta, format = "html", digits = 2, caption = "Statystyki opisowe zmiennych jakościowych", col.names = c("Zmienna", "Liczba obserwacji", "Liczba braków", "% kompletności", "Liczba kategorii")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
kable(tab_bin, format = "html", digits = 2, caption = "Procent 'tak' w zmiennych binarnych", col.names = c("Zmienna", "Liczba obserwacji", "Liczba braków", "Liczba niebraków", "Liczba 'tak'", "% 'tak'")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


# =====================================================================================================

# zmienne dyskretne 
tab_disc <- dane_imputed %>%
  select(c("rooms", "floor", "floorCount", "buildYear", "poiCount")) %>%
  skim()%>%
  # dplyr::filter(skim_type == "numeric") %>%
  dplyr::select(
    zmienna = skim_variable,
    complete_rate,
    mean = `numeric.mean`,
    sd   = `numeric.sd`,
    min  = `numeric.p0`,
    q1   = `numeric.p25`,
    median = `numeric.p50`,
    q3   = `numeric.p75`,
    max  = `numeric.p100`
  ) %>%
  mutate(complete_rate = round(complete_rate * 100, 1), zmienna = label_vars(zmienna))
### Niektóre zmienne (rok budowy, liczba punktów POI) wykazują znaczną zmienność i skośność, co zostało uwzględnione na etapie modelowania ###
# zmienne ciagle
cont_vars <- c("squareMeters","price","price_m2")
tab_num <- dane_imputed %>%
  select(all_of(cont_vars))%>%
  skim()%>%
  # dplyr::filter(skim_type == "numeric") %>%
  dplyr::select(
    zmienna = skim_variable,
    complete_rate,
    mean = `numeric.mean`,
    sd   = `numeric.sd`,
    min  = `numeric.p0`,
    q1   = `numeric.p25`,
    median = `numeric.p50`,
    q3   = `numeric.p75`,
    max  = `numeric.p100`
  ) %>%
  mutate(complete_rate = round(complete_rate * 100, 1), zmienna = label_vars(zmienna))
# zmienne odlegosciowe
  dist_vars <- c("centreDistance","schoolDistance","clinicDistance","postOfficeDistance",
               "kindergartenDistance","restaurantDistance","collegeDistance","pharmacyDistance")
tab_od <- dane_imputed %>%
  select(all_of(dist_vars)) %>%
  skim()%>%
  # dplyr::filter(skim_type == "numeric") %>%
  dplyr::select(
    zmienna = skim_variable,
    complete_rate,
    mean = `numeric.mean`,
    sd   = `numeric.sd`,
    min  = `numeric.p0`,
    q1   = `numeric.p25`,
    median = `numeric.p50`,
    q3   = `numeric.p75`,
    max  = `numeric.p100`
  ) %>%
  mutate(complete_rate = round(complete_rate * 100, 1), zmienna = label_vars(zmienna))

kable(tab_disc, format = "html", digits = 2, caption = "Statystyki opisowe (zmienne dyscretne)", col.names = c("Zmienna", "% kompletności", "Średnia", "Odch. std.", "Min", "Q1", "Mediana", "Q3", "Max")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
kable(tab_num, format = "html", digits = 2, caption = "Statystyki opisowe (zmienne numeryczne)", col.names = c("Zmienna", "% kompletności", "Średnia", "Odch. std.", "Min", "Q1", "Mediana", "Q3", "Max")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
kable(tab_od, format = "html", digits = 2, caption = "Statystyki opisowe (zmienne odlegościowe)", col.names = c("Zmienna", "% kompletności", "Średnia", "Odch. std.", "Min", "Q1", "Mediana", "Q3", "Max")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```

```{r}
# testy statystyczne 
library(ggstatsplot)

ggbetweenstats(
  data = dane_clean,
  x = hasBalcony,
  y = price,
  title = "Wpływ balkonu na cenę mieszkania",
  xlab = "Balkon",
  ylab = "Cena (PLN)"
) 
# ilościowe

# jajosciowe 

```
