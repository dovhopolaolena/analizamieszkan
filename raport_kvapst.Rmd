```{r lib}
library(tidyverse)
library(validate)
library(readr)
library(dplyr)
library(naniar)
library(finalfit)
library(mice)
library(ggplot2)
library(kableExtra)
library(summarytools)
library(ggridges)
library(gtsummary)
library(frequency)
library(corrplot)
library(ggpubr)
library(skimr)
library(leaflet)
library(leaflet.extras)
library(tidyr)
library(gt)
library(ggstatsplot)
library(ggcorrplot)
library(rstatix)
library(modelsummary)
library(car)
library(sandwich)
library(lmtest)
```

SPRAWDZANIE CZY SA DUPLICATY, FILTRACJA DANYCH PO MIASTU

```{r wstep}
dane<-read_csv("apartments_pl_2024_06.csv")
dane<-filter(dane, city=="gdansk")
sum(duplicated(dane))#  brak duplikatów-> mozna usunąć kolumne id i iine nie potrzebne kolumny
# takie wstępne przygotowanie danych
dane_gdansk <- dane %>%
  select(-c(id, condition, buildingMaterial,city))%>%
  mutate(across(where(is.character),as.factor))%>%
  mutate(price_m2 = price / squareMeters)
# slowniki do etykietowania zmiennych 
var_labels <- c(
  type = "Typ budynku",
  squareMeters = "Powierzchnia mieszkania [m²]",
  rooms = "Liczba pokoi",
  floor = "Piętro",
  floorCount = "Liczba kondygnacji w budynku",
  buildYear = "Rok budowy",
  latitude = "Szerokość geograficzna",
  longitude = "Długość geograficzna",
  centreDistance = "Odległość od centrum [km]",
  poiCount = "Liczba punktów POI w pobliżu",
  schoolDistance = "Odległość do szkoły [km]",
  clinicDistance = "Odległość do przychodni [km]",
  postOfficeDistance = "Odległość do poczty [km]",
  kindergartenDistance = "Odległość do przedszkola [km]",
  restaurantDistance = "Odległość do restauracji [km]",
  collegeDistance = "Odległość do uczelni [km]",
  pharmacyDistance = "Odległość do apteki [km]",
  ownership = "Forma własności",
  hasParkingSpace = "Miejsce parkingowe",
  hasBalcony = "Balkon",
  hasElevator = "Winda",
  hasSecurity = "Ochrona",
  hasStorageRoom = "Komórka lokatorska",
  price = "Cena całkowita [PLN]",
  price_m2 = "Cena za metr kwadratowy [PLN/m²]"
)
var_labels <- as.list(var_labels)
label_vars <- function(x) {
  sapply(as.character(x), function(v) var_labels[[v]])
}

# mapa mieszka -> NIE WIEM W KTÓRYM MOMENCIE NAJLEPIEJ JĄ DODAĆ
leaflet(dane_gdansk) |>
  addTiles() |>
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = 3,
    stroke = FALSE,
    fillOpacity = 0.4
  )
```

#### **Hipoteza główna (H):**

Apartamenty o większym metrażu osiągają wyższe ceny całkowite, ale mieszkania o mniejszym metrażu mają wyższe ceny za metr kwadratowy.

Metraż mieszkania istotnie różnicuje poziom cen na rynku nieruchomości, zarówno w ujęciu ceny całkowitej, jak i ceny za metr kwadratowy.

sPRAWDZANIE NA NIE SPÓJNOŚCI DANYCH I BLEDOW LOGICZNYCH Wyniki walidacji reguł twardych nie wykazały żadnych naruszeń spójności logicznej ani dziedzinowej. W związku z brakiem przypadków niespełniających przyjętych warunków, szczegółowe zestawienie tabelaryczne reguł walidacyjnych pominięto, ograniczając prezentację do opisu procedury. Przed imputacją przeprowadzono walidację twardą i miękką regułami logicznymi/dziedzinowymi. Walidacja twarda nie wykazała naruszeń. Reguły miękkie wykazały jedynie przypadki nietypowe, które pozostawiono w zbiorze jako obserwacje potencjalnie realistyczne. W konsekwencji zbiór uznano za spójny do dalszych etapów analizy

```{r walidacja}
# sprawdzanie występowania braków danych, żeby wiedzieć gdzie w regułach musimy dopuśćić wystapowanie NA
miss_var_summary(dane_gdansk)
# reguly: dla zmiennych, w których nie występowały braki danych, nie uwzględniano warunku is.na(). Dla pozostałych zmiennych braki danych pozostawiono i traktowano jako dopuszczalne
rules_hard <- validator(

  squareMeters > 0,
  squareMeters <= 250,

  rooms >= 1,
  rooms <= 8,         

  squareMeters >= rooms * 8,      
  squareMeters <= rooms * 40,     

  floor >= 0 | is.na(floor),     
  floorCount >= 1 | is.na(floorCount),
  floor <= floorCount | is.na(floor) | is.na(floorCount),

  buildYear >= 1850 | is.na(buildYear),
  buildYear <= 2025 | is.na(buildYear),
  
  centreDistance >= 0,
  schoolDistance >= 0 | is.na(schoolDistance),
  clinicDistance >= 0 | is.na(clinicDistance),
  postOfficeDistance >= 0 | is.na(postOfficeDistance),
  kindergartenDistance >= 0 | is.na(kindergartenDistance),
  restaurantDistance >= 0 | is.na(restaurantDistance),
  collegeDistance >= 0 | is.na(collegeDistance),
  pharmacyDistance >= 0 | is.na(pharmacyDistance),

  centreDistance <= 20,
  schoolDistance <= 10 | is.na(schoolDistance),
  clinicDistance <= 10 | is.na(clinicDistance),
  postOfficeDistance <= 10 | is.na(postOfficeDistance),
  kindergartenDistance <= 10 | is.na(kindergartenDistance),
  restaurantDistance <= 10 | is.na(restaurantDistance),
  collegeDistance <= 15 | is.na(collegeDistance),
  pharmacyDistance <= 10 | is.na(pharmacyDistance),

  poiCount >= 0,
  poiCount <= 300,               

  type %in% c("tenement","blockOfFlats","apartmentBuilding") | is.na(type),
  ownership %in% c("condominium","cooperative"),

  hasParkingSpace %in% c("yes","no"),
  hasBalcony %in% c("yes","no"),
  hasElevator %in% c("yes","no") | is.na(hasElevator),
  hasSecurity %in% c("yes","no"),
  hasStorageRoom %in% c("yes","no"),

  price > 0,
  price / squareMeters >= 8000,
  price / squareMeters <= 35000
)
out_hard <- confront(dane_gdansk, rules_hard)
summary(out_hard)
out <- confront(dane_gdansk, rules_hard)
summary(out)
summary(out_hard)$fails

rules_soft <- validator(

  !(buildYear < 1945 & floorCount > 7) | is.na(buildYear) | is.na(floorCount),
  !(floor >= 5 & buildYear >= 1995 & hasElevator == "no") | is.na(floor) | is.na(buildYear) | is.na(hasElevator),
  !(squareMeters < 35 & rooms >= 3),
  !(squareMeters > 80 & rooms == 1)
)
out_soft <- confront(dane_gdansk, rules_soft)
summary(out_soft)
summary(out_soft)$fails


# Dla zmiennych, w których nie występowały braki danych, nie uwzględniano warunku is.na(). Dla pozostałych zmiennych braki danych pozostawiono i traktowano jako dopuszczalne
```

dentyfikacja outlierów metodą IQR

```{r iqr}
# wybór zmiennych numerycznych
num_vars <- dane_gdansk %>% select(where(is.numeric))

iqr_outliers <- num_vars %>%
  summarise(across(
    everything(),
    ~ {
      q1 <- quantile(.x, 0.25, na.rm = TRUE)
      q3 <- quantile(.x, 0.75, na.rm = TRUE)
      iqr <- IQR(.x, na.rm = TRUE)
      mean(.x < (q1 - 1.5 * iqr) | .x > (q3 + 1.5 * iqr), na.rm = TRUE) * 100})) %>%
  pivot_longer(
    everything(),
    names_to = "variable",
    values_to = "pct_outliers") %>%
  arrange(desc(pct_outliers))

kable(iqr_outliers %>%
        mutate(variable = label_vars(variable))%>%
        mutate(pct_outliers = round(pct_outliers, 2)) %>%
        filter(pct_outliers!= 0),
      format = "html", digits = 2,caption = "Identyfikacja wartości odstających (IQR)",col.names = c("Zmienna", "% obserwacji odstających")) %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```

2.1 Braki danych W celu określenia mechanizmu braków danych przeprowadzono test Little MCAR. Wynik testu był istotny statystycznie (χ² = 2374.25, df = 569, p \< 0.001), co pozwala odrzucić hipotezę o całkowicie losowym charakterze braków (MCAR). Oznacza to, że zmienne w zbiorze zawierają braki zależne od innych informacji (MAR) lub od wartości samej zmiennej (MNAR). Braki danych nie mają więc charakteru losowego i wymagają zastosowania zaawansowanej metody imputacji, takiej jak MICE. floor, rokbudowy, czy jest winda, odleglosc od uni Z brakami danych do uzupelnienia. Type i reszta zostaje z brakami danych, bo nie oplaca sie -\> jak to uzasadnić?

mice dla zmiennych numerycznych buduje model liniowy, dla kategorzycznych logitowy

```{r t_NA}
mcar_test(dane_gdansk)
gg_miss_var(dane_gdansk)
vis_miss(dane_gdansk)
gg_miss_upset(dane_gdansk)
missing_pattern(dane_gdansk)
```

W zbiorze danych przeprowadzono analizę braków, której celem było określenie ich zakresu, struktury oraz mechanizmu powstawania. Łączny odsetek braków wyniósł około 3%, jednak nie były one równomiernie rozłożone między zmiennymi. Najwięcej braków odnotowano w zmiennych type, floor oraz buildYear, co wskazuje, że dotyczą one głównie informacji opisujących cechy budynku. Pozostałe zmienne charakteryzowały się znikomym poziomem braków.

Wizualizacje braków, w tym mapy ciepła oraz wykresy typu vis_miss i UpSet Plot, wykazały istnienie wyraźnych wzorców współwystępowania brakujących wartości, co sugeruje, że nie mają one charakteru przypadkowego.

Ze względu na nielosowy charakter braków oraz ich koncentrację w wybranych zmiennych, do uzupełnienia danych zastosowano metodę imputacji wielokrotnej MICE. Metoda ta pozwala odtworzyć brakujące wartości w sposób zgodny z zależnościami występującymi w zbiorze, ograniczając ryzyko zniekształcenia wyników dalszej analizy. Zmienne o minimalnej liczbie braków pozostawiono bez imputacji, gdyż ich wpływ na modele jest pomijalny. Dzięki przeprowadzonej imputacji uzyskano kompletny i spójny zbiór danych, odpowiedni do kolejnych etapów modelowania.

ggmice

```{r imputacja}
methods <- make.method(dane_gdansk)
methods[] <- ""

methods["floor"]           <- "pmm"
methods["buildYear"]       <- "pmm"
methods["hasElevator"]     <- "logreg"
methods["collegeDistance"] <- "pmm"
methods["type"]            <- ""   

pred <- make.predictorMatrix(dane_gdansk)
pred[,] <- 0
diag(pred) <- 0

pred["floor", c("floorCount","rooms","squareMeters","buildYear","hasElevator","poiCount")] <- 1
pred["buildYear", c("floorCount","centreDistance","poiCount","squareMeters","rooms")] <- 1
pred["hasElevator", c("floorCount","buildYear","floor")] <- 1
pred["collegeDistance", c("centreDistance","poiCount","latitude","longitude")] <- 1
pred[, "type"] <- 0
pred["type", ] <- 0

set.seed(123)
imp <- mice(dane_gdansk, method = methods, predictorMatrix = pred, m = 5, maxit = 20, ridge = 1e-5)
dane_imputed <- complete(imp, 1)

```

```{r imp_graphs}
plot(imp)

densityplot(imp, ~ floor)
densityplot(imp, ~ buildYear)
densityplot(imp, ~ collegeDistance)

# 5) Relacje między zmiennymi (czy imputacja nie psuje logiki)
xyplot(imp, floor ~ floorCount)

# 6) Stripplot (czy imputacje nie „przyklejają się” do jednej wartości)
# Dobry do wykrywania degeneracji imputacji
stripplot(imp, floor ~ .imp, pch = 20, cex = 1)
stripplot(imp, buildYear ~ .imp, pch = 20, cex = 1)
stripplot(imp, collegeDistance ~ .imp, pch = 20, cex = 1)


```
dane jakosciowe Rozdzial X : analiza opisowa i wizualizacja zmiennych jakościowych Wykresy i statystyki opisowe do świąt

```{r wykresy}
# # metraż a cena
dane_imputed %>%
  mutate(
    size_bin = cut(
      squareMeters,
      breaks = c(0, 30, 50, 70, 90, 120, Inf),
      labels = c("<30","30–50","50–70","70–90","90–120","120+")
    )
  ) %>%
  ggplot(aes(x = size_bin, y = price)) +
  geom_boxplot(fill = "#9ecae1") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Rozkład cen mieszkań według przedziałów metrażu",
    x = "Metraż [m²]",
    y = "Cena [PLN]"
  ) +
  theme_minimal()

dane_imputed %>%
  mutate(
    centre_bin = cut(
      centreDistance,
      breaks = c(0, 1, 3, 5, 8, Inf),
      labels = c("≤1 km","1–3","3–5","5–8",">8")
    )
  ) %>%
  ggplot(aes(x = centre_bin, y = price_m2)) +
  geom_boxplot(fill = "#c7e9c0") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Cena za m² w zależności od odległości od centrum",
    x = "Odległość od centrum",
    y = "Cena za m² [PLN]"
  ) +
  theme_minimal()
dane_imputed %>%
  filter(!is.na(floor), hasElevator %in% c("yes","no"))%>%
  mutate(
    floor_bin = cut(floor, breaks = c(-Inf,1,3,5,10,Inf),
                    labels = c("1","2–3","4–5","6–10","11+"))
  ) %>%
  ggplot(aes(x = floor_bin, y = price_m2, fill = hasElevator)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Znaczenie windy w zależności od piętra",
    x = "Piętro",
    y = "Cena za m² [PLN]",
    fill = "Winda"
  ) +
  theme_minimal()
ggplot(dane_imputed, aes(x = hasBalcony, y = price_m2)) +
  geom_violin(fill = "#9ecae1", alpha = 0.7, trim = TRUE) +
  geom_boxplot(width = 0.1, fill = "white") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Rozkład ceny za m² – balkon vs brak balkonu",
    x = "Balkon",
    y = "Cena za m² [PLN]"
  ) +
  theme_minimal()
###  Różnice cen za m² pomiędzy mieszkaniami z balkonem i bez balkonu są relatywnie niewielkie w porównaniu z innymi czynnikami ### 


# ETU TOCZNO OSZTAWLIAJEM
pal <- colorNumeric("viridis", domain = dane_imputed$price_m2, na.color = "transparent")

leaflet(dane_imputed) %>%
  addProviderTiles("CartoDB.Positron") %>%
  addCircleMarkers(
    lng = ~longitude, lat = ~latitude,
    radius = 3,
    stroke = FALSE,
    fillOpacity = 0.6,
    color = ~pal(price_m2),
    clusterOptions = markerClusterOptions()
  ) %>%
  addLegend("bottomright", pal = pal, values = ~price_m2,
            title = "Cena za m² [PLN]", labFormat = labelFormat())

```

```{r staystyki, results='asis', echo=FALSE}
cat_vars <- c(
  "type","ownership","hasParkingSpace","hasBalcony",
  "hasElevator","hasSecurity","hasStorageRoom"
)

tab_cat_meta <- dane_imputed %>%
  select(all_of(cat_vars)) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "val") %>%
  group_by(variable) %>%
  summarise(
    liczba_obserwacji = n(),
    liczba_brakow = sum(is.na(val)),
    `%_kompletnosci` = round((1 - liczba_brakow / liczba_obserwacji) * 100, 1),
    liczba_kategorii = n_distinct(val, na.rm = TRUE),
    .groups = "drop"
  )
bin_vars <- c("hasParkingSpace","hasBalcony","hasElevator","hasSecurity","hasStorageRoom")

tab_bin <- dane_imputed %>%
  select(all_of(bin_vars)) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "val") %>%
  mutate(val = tolower(as.character(val))) %>%
  group_by(variable) %>%
  summarise(
    n = n(),
    missing = sum(is.na(val)),
    n_nonmiss = n - missing,
    yes_n = sum(val %in% c("yes"), na.rm = TRUE),
    yes_pct = round(yes_n / n_nonmiss * 100, 1),
    .groups = "drop"
  )
tab_bin_final <- tab_bin %>% select(variable, n_nonmiss, yes_n, yes_pct)

tab_cat_meta <- tab_cat_meta %>% mutate(variable = label_vars(variable))
tab_bin <- tab_bin_final %>% mutate(variable = label_vars(variable))

kable(tab_cat_meta, format = "html", digits = 2, caption = "Statystyki opisowe zmiennych jakościowych", col.names = c("Zmienna", "Liczba obserwacji", "Liczba braków", "% kompletności", "Liczba kategorii")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

kable(tab_bin_final,format = "html",digits = 2,caption = "Struktura zmiennych binarnych – udział odpowiedzi „tak”",col.names = c("Zmienna","Liczba obserwacji","Liczba „tak”","% „tak”")) %>%
  kable_styling(full_width = FALSE,bootstrap_options = c("striped", "hover"))
# =====================================================================================================

# zmienne dyskretne 
tab_disc <- dane_imputed %>%
  select(c("rooms", "floor", "floorCount", "buildYear", "poiCount")) %>%
  skim()%>%
  # dplyr::filter(skim_type == "numeric") %>%
  dplyr::select(
    zmienna = skim_variable,
    complete_rate,
    mean = `numeric.mean`,
    sd   = `numeric.sd`,
    min  = `numeric.p0`,
    q1   = `numeric.p25`,
    median = `numeric.p50`,
    q3   = `numeric.p75`,
    max  = `numeric.p100`
  ) %>%
  mutate(complete_rate = round(complete_rate * 100, 1), zmienna = label_vars(zmienna))
### Niektóre zmienne (rok budowy, liczba punktów POI) wykazują znaczną zmienność i skośność, co zostało uwzględnione na etapie modelowania ###
# zmienne ciagle
cont_vars <- c("squareMeters","price","price_m2")
tab_num <- dane_imputed %>%
  select(all_of(cont_vars))%>%
  skim()%>%
  # dplyr::filter(skim_type == "numeric") %>%
  dplyr::select(
    zmienna = skim_variable,
    complete_rate,
    mean = `numeric.mean`,
    sd   = `numeric.sd`,
    min  = `numeric.p0`,
    q1   = `numeric.p25`,
    median = `numeric.p50`,
    q3   = `numeric.p75`,
    max  = `numeric.p100`
  ) %>%
  mutate(complete_rate = round(complete_rate * 100, 1), zmienna = label_vars(zmienna))
# zmienne odlegosciowe
  dist_vars <- c("centreDistance","schoolDistance","clinicDistance","postOfficeDistance",
               "kindergartenDistance","restaurantDistance","collegeDistance","pharmacyDistance")
tab_od <- dane_imputed %>%
  select(all_of(dist_vars)) %>%
  skim()%>%
  # dplyr::filter(skim_type == "numeric") %>%
  dplyr::select(
    zmienna = skim_variable,
    complete_rate,
    mean = `numeric.mean`,
    sd   = `numeric.sd`,
    min  = `numeric.p0`,
    q1   = `numeric.p25`,
    median = `numeric.p50`,
    q3   = `numeric.p75`,
    max  = `numeric.p100`
  ) %>%
  mutate(complete_rate = round(complete_rate * 100, 1), zmienna = label_vars(zmienna))

kable(tab_disc, format = "html", digits = 2, caption = "Statystyki opisowe (zmienne dyscretne)", col.names = c("Zmienna", "% kompletności", "Średnia", "Odch. std.", "Min", "Q1", "Mediana", "Q3", "Max")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
kable(tab_num, format = "html", digits = 2, caption = "Statystyki opisowe (zmienne numeryczne)", col.names = c("Zmienna", "% kompletności", "Średnia", "Odch. std.", "Min", "Q1", "Mediana", "Q3", "Max")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
kable(tab_od, format = "html", digits = 2, caption = "Statystyki opisowe (zmienne odlegościowe)", col.names = c("Zmienna", "% kompletności", "Średnia", "Odch. std.", "Min", "Q1", "Mediana", "Q3", "Max")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```

```{r testowanie hipotez}
# „Kluczowe zmienne wykorzystywane w analizie wnioskowania statystycznego nie zawierały braków danych, co pozwoliło na przeprowadzenie testów bez dodatkowej redukcji próby
# HIPOTEZA 1 i 4 -> korelacje rang Spearmana
h1_results <- dane_imputed %>%
  cor_test(centreDistance, c(price, price_m2), method = "spearman")

h1_results

h4_results <- dane_imputed %>%
  cor_test(squareMeters, c(price, price_m2), method = "spearman")

h4_results

# wybór kluczowych zmiennych do korelacji (H1 + H4)
vars_cor <- dane_imputed %>% 
  select(centreDistance, squareMeters, price, price_m2)
cor_mat <- cor(vars_cor, method = "spearman", use = "complete.obs")

ggcorrplot(cor_mat, lab = TRUE) +
  scale_x_discrete(labels = label_vars) +
  scale_y_discrete(labels = label_vars) +
  scale_fill_gradient2(
    low = "#2166ac",
    mid = "white",
    high = "#b2182b",
    midpoint = 0,
    limits = c(-1, 1)
  ) +
  labs(
    title = "Korelacje rang Spearmana między kluczowymi cechami mieszkań"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1),
    axis.title = element_blank(),
    plot.title = element_text(face = "bold"),
    legend.position = "none"
  )


# HIPOTEZA 2 -> test U Manna–Whitneya dla zmiennych binarnych

ggbetweenstats(
  data = dane_imputed,
  x = hasElevator,
  y = price_m2,
  type = "nonparametric",   #
  conf.level = 0.95,
  xlab = "Winda",
  ylab = "Cena za m² [PLN]",
  title = "Cena za m² a obecność windy",
  caption = "Test U Manna–Whitneya"
)

# Rysunek przedstawia rozkład cen za m² mieszkań z windą i bez windy wraz z wynikami testu U Manna–Whitneya, ilustrując istotną statystycznie różnicę pomiędzy grupami

h2_wilcox <-  dane_imputed %>%
  select(price_m2, all_of(bin_vars)) %>%
  pivot_longer(
    cols = all_of(bin_vars),
    names_to = "feature",
    values_to = "group") %>%
  filter(group %in% c("yes", "no")) %>%
  group_by(feature) %>%
  wilcox_test(price_m2 ~ group) %>%
  add_significance("p") %>%
  ungroup()

h2_medians <-  dane_imputed %>%
  select(price_m2, all_of(bin_vars)) %>%
  pivot_longer(
    cols = all_of(bin_vars),
    names_to = "feature",
    values_to = "group") %>%
  filter(group %in% c("yes", "no")) %>%
  group_by(feature, group) %>%
  summarise(
    n = n(),
    median = median(price_m2),
    .groups = "drop")

h2_effect <-  dane_imputed %>%
  select(price_m2, all_of(bin_vars)) %>%
  pivot_longer(
    cols = all_of(bin_vars),
    names_to = "feature",
    values_to = "group"
  ) %>%
  filter(group %in% c("yes", "no")) %>%
  group_by(feature) %>%
  wilcox_effsize(price_m2 ~ group)

h2_results <- h2_wilcox %>%
  left_join(h2_effect, by = "feature") %>%
  left_join(h2_medians, by = "feature")


h2_results <- h2_results %>%
  adjust_pvalue(method = "BH")

h2_pub <- h2_results %>%
  select(feature,statistic, p, p.signif,effsize, magnitude,group, n, median) %>%
  pivot_wider(
    names_from = group,
    values_from = c(n, median),
    names_glue = "{.value}_{group}") %>%
  mutate(
    median_no  = round(median_no, 2),
    median_yes = round(median_yes, 2),
    effsize    = round(effsize, 3),
    p          = signif(p, 4)) %>%
  select(feature,n_no, n_yes,median_no, median_yes,statistic, p, p.signif,effsize, magnitude)
h2_pub <- h2_pub %>%
  mutate(feature = label_vars(feature))

kable(
  h2_pub,
  format = "html",
  caption = "H2: Porównanie ceny za m² między mieszkaniami z cechą standardu i bez (test U Manna–Whitneya)",
  col.names = c(
    "Cecha", "Ilość (bez)", "Ilość (z)",
    "Mediana (bez)", "Mediana (z)",
    "W", "p-value", "",
    "r", "Wielkość efektu"
  ),
  digits = 2
) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover")) %>%
  column_spec(1, bold = TRUE) %>%
  column_spec(7, bold = TRUE) %>%
  scroll_box(width = "100%", height = "350px")

bin_vars <- c("hasParkingSpace","hasBalcony","hasElevator","hasSecurity","hasStorageRoom")
# 2) Wyniki korelacji Spearmana w grupach yes/no
h3_results <- dane_imputed %>%
  select(centreDistance, price_m2, all_of(bin_vars)) %>%
  pivot_longer(
    cols = all_of(bin_vars),
    names_to = "feature",
    values_to = "group"
  ) %>%
  filter(group %in% c("yes", "no")) %>%
  group_by(feature, group) %>%
  cor_test(centreDistance, price_m2, method = "spearman") %>%
  ungroup()

# 3) Tabela do raportu: 1 wiersz na cechę
h3_pub <- h3_results %>%
  transmute(
    feature,
    group,
    rho = round(cor, 2),
    p   = signif(p, 3)
  ) %>%
  pivot_wider(
    names_from = group,
    values_from = c(rho, p),
    names_glue = "{.value}_{group}"
  )
h3_pub <- h3_pub %>%
  mutate(feature = label_vars(feature))

h3_results
h3_pub


h3_table <- h3_pub %>%
  mutate(
    `Δρ` = round(rho_yes - rho_no, 2),
    p_no  = ifelse(p_no  < 0.001, "<0.001", format(p_no,  digits = 3)),
    p_yes = ifelse(p_yes < 0.001, "<0.001", format(p_yes, digits = 3))
  ) %>%
  select(
    Cecha = feature,
    `ρ (bez cechy)` = rho_no,
    `ρ (z cechą)`   = rho_yes,
    `Δρ`,
    `p (bez cechy)` = p_no,
    `p (z cechą)`   = p_yes
  )

kable(
  h3_table,
  format = "html",
  escape = FALSE,
  caption = "H3: Korelacja Spearmana (odległość od centrum vs cena za m²) w grupach standardu"
) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed")) %>%
  column_spec(2:4, bold = TRUE)
kable(
  h3_pub,
  format = "html",
  caption = "H3: Zależność odległości od centrum i ceny za m² w grupach standardu (korelacja Spearmana)",
  col.names = c(
    "Cecha",
    "ρ (bez)",
    "ρ (z)",
    "p (bez)",
    "p (z)"
  ),
  digits = 2
) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover")) %>%
  column_spec(1, bold = TRUE)


```


```{r}
df <- dane_imputed %>%
  mutate(
    ln_price_m2 = log(price_m2),
    ln_centre = log1p(centreDistance),   
    ln_poi = log1p(poiCount),
    ln_area = log(squareMeters),
    rooms = factor(rooms),
    type = factor(type),
    ownership = factor(ownership),
    hasElevator     = factor(hasElevator, levels = c("no","yes")),
    hasSecurity     = factor(hasSecurity, levels = c("no","yes")),
    hasStorageRoom  = factor(hasStorageRoom, levels = c("no","yes")),
    hasBalcony      = factor(hasBalcony, levels = c("no","yes")),
    hasParkingSpace = factor(hasParkingSpace, levels = c("no","yes"))) %>%
  filter(
    is.finite(ln_price_m2),
    is.finite(ln_centre),
    is.finite(ln_area),
    !is.na(buildYear),
    !is.na(floor),
    !is.na(floorCount))


m0 <- lm(ln_price_m2 ~ ln_centre, data = df)
summary(m0)
coeftest(m0, vcov = vcovHC(m_final, "HC1"))

m1 <- lm(ln_price_m2 ~ ln_centre + ln_area + rooms +buildYear + floor + floorCount,data = df)
summary(m1)
coeftest(m1, vcov = vcovHC(m_final, "HC1"))
vif(m1)

m2 <- lm(ln_price_m2 ~ ln_centre + ln_area + rooms +buildYear + floor + floorCount +ln_poi + schoolDistance + restaurantDistance,data =df)
summary(m2)
coeftest(m2, vcov = vcovHC(m_final, "HC1"))
vif(m2)

m3 <- lm(ln_price_m2 ~ ln_centre + ln_area + rooms +buildYear + floor + floorCount +ln_poi + schoolDistance + restaurantDistance+hasElevator + hasBalcony + hasSecurity +hasStorageRoom + hasParkingSpace,data = df)
summary(m3)
coeftest(m3, vcov = vcovHC(m_final, "HC1"))
vif(m3)

m4 <- lm(ln_price_m2 ~ ln_centre + ln_area + rooms +buildYear + floor + floorCount +ln_poi + schoolDistance + restaurantDistance+hasElevator + hasSecurity + hasStorageRoom +ln_centre:hasElevator +ln_centre:hasStorageRoom,data = df)
summary(m4)
coeftest(m4, vcov = vcovHC(m4, type = "HC1"))
bptest(m4)
vif(m4)

m_final <- lm( ln_price_m2 ~ ln_centre +ln_area +buildYear +floor +ln_poi +hasElevator +hasStorageRoom+ ln_centre:hasElevator+ln_centre:hasStorageRoom,data = df)
summary(m_final)
coeftest(m_final, vcov = vcovHC(m_final, "HC1"))
vif(m_final)

model_summary_extended <- tibble::tibble(
  Model = c("Model 0", "Model 1", "Model 2", "Model 3", "Model 4", "Model Final"),
  `R² (adj)` = c(
    round(summary(m0)$adj.r.squared, 3),
    round(summary(m1)$adj.r.squared, 3),
    round(summary(m2)$adj.r.squared, 3),
    round(summary(m3)$adj.r.squared, 3),
    round(summary(m4)$adj.r.squared, 3),
    round(summary(m_final)$adj.r.squared, 3)
  ),
  `Błąd standardowy` = c(
    round(sigma(m0), 3),
    round(sigma(m1), 3),
    round(sigma(m2), 3),
    round(sigma(m3), 3),
    round(sigma(m4), 3),
    round(sigma(m_final), 3)
  ),
  AIC = c(
    AIC(m0),
    AIC(m1),
    AIC(m2),
    AIC(m3),
    AIC(m4),
    AIC(m_final)
  ),
  BIC = c(
    BIC(m0),
    BIC(m1),
    BIC(m2),
    BIC(m3),
    BIC(m4),
    BIC(m_final)
  ),
  `Log-Likelihood` = c(
    logLik(m0),
    logLik(m1),
    logLik(m2),
    logLik(m3),
    logLik(m4),
    logLik(m_final)
  ),
  `Liczba obserwacji` = c(
    nobs(m0),
    nobs(m1),
    nobs(m2),
    nobs(m3),
    nobs(m4),
    nobs(m_final)
  ),
  `Liczba zmiennych` = c(
    length(coef(m0)),
    length(coef(m1)),
    length(coef(m2)),
    length(coef(m3)),
    length(coef(m4)),
    length(coef(m_final))
  ),
  `VIF > 5` = c(
    NA,
    sum(vif(m1) > 5),
    sum(vif(m2) > 5),
    sum(vif(m3) > 5),
    sum(vif(m4) > 5),
    sum(vif(m_final) > 5)
  )
)

# Generowanie tabeli z kableExtra
model_summary_extended %>%
  kable(
    format = "html",
    caption = "Podsumowanie wyników regresji – różne modele",
    col.names = c("Model", "R² (adj)", "Błąd standardowy", "AIC", "BIC", "Log-Likelihood", "Liczba obserwacji", "Liczba zmiennych", "VIF > 5")
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed")) %>%
  row_spec(0, bold = TRUE, background = "#D3D3D3") %>%
  column_spec(2:5, bold = TRUE) %>%
  column_spec(9, color = "red") # wyróżnienie kolumny VIF
```
```



```








```
