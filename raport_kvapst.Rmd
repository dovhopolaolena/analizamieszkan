```{r}
library(tidyverse)
library(validate)
library(readr)
library(dplyr)
library(naniar)
library(finalfit)
library(mice)
library(ggplot2)
library(kableExtra)
library(summarytools)
library(gtsummary)
library(frequency)
library(corrplot)
library(ggpubr)
library(leaflet)
library(tidyr)
library(gt)
```

SPRAWDZANIE CZY SA DUPLICATY, FILTRACJA DANYCH PO MIASTU

```{r}
dane<-read_csv("apartments_pl_2024_06.csv")
dane<-filter(dane, city=="gdansk")
sum(duplicated(dane))#  brak duplikatów-> mozna usunąć kolumne id i iine nie potrzebne kolumny
dane_gdansk <- dane %>%
  select(-c(id, condition, buildingMaterial,city))
dane_gdansk%>%
  mutate(across(
    where(is.character),
    as.factor
  ))
var_labels <- c(
  type = "Typ budynku",
  squareMeters = "Powierzchnia mieszkania [m²]",
  rooms = "Liczba pokoi",
  floor = "Piętro",
  floorCount = "Liczba kondygnacji w budynku",
  buildYear = "Rok budowy",
  latitude = "Szerokość geograficzna",
  longitude = "Długość geograficzna",
  centreDistance = "Odległość od centrum [km]",
  poiCount = "Liczba punktów POI w pobliżu",
  schoolDistance = "Odległość do szkoły [km]",
  clinicDistance = "Odległość do przychodni [km]",
  postOfficeDistance = "Odległość do poczty [km]",
  kindergartenDistance = "Odległość do przedszkola [km]",
  restaurantDistance = "Odległość do restauracji [km]",
  collegeDistance = "Odległość do uczelni [km]",
  pharmacyDistance = "Odległość do apteki [km]",
  ownership = "Forma własności",
  hasParkingSpace = "Miejsce parkingowe",
  hasBalcony = "Balkon",
  hasElevator = "Winda",
  hasSecurity = "Ochrona",
  hasStorageRoom = "Komórka lokatorska",
  price = "Cena całkowita [PLN]"
)

label_vars <- function(x) {recode(x, !!!var_labels)}

# mapa mieszka -> NIE WIEM W KTÓRYM MOMENCIE NAJLEPIEJ JĄ DODAĆ
leaflet(dane_gdansk) |>
  addTiles() |>
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = 3,
    stroke = FALSE,
    fillOpacity = 0.4
  )

```

#### **Hipoteza główna (H):**

Apartamenty o większym metrażu osiągają wyższe ceny całkowite, ale mieszkania o mniejszym metrażu mają wyższe ceny za metr kwadratowy.

Metraż mieszkania istotnie różnicuje poziom cen na rynku nieruchomości, zarówno w ujęciu ceny całkowitej, jak i ceny za metr kwadratowy.

sPRAWDZANIE NA NIE SPÓJNOŚCI DANYCH I BLEDOW LOGICZNYCH Wyniki walidacji reguł twardych nie wykazały żadnych naruszeń spójności logicznej ani dziedzinowej. W związku z brakiem przypadków niespełniających przyjętych warunków, szczegółowe zestawienie tabelaryczne reguł walidacyjnych pominięto, ograniczając prezentację do opisu procedury. Przed imputacją przeprowadzono walidację twardą i miękką regułami logicznymi/dziedzinowymi. Walidacja twarda nie wykazała naruszeń. Reguły miękkie wykazały jedynie przypadki nietypowe, które pozostawiono w zbiorze jako obserwacje potencjalnie realistyczne. W konsekwencji zbiór uznano za spójny do dalszych etapów analizy

```{r}
# sprawdzanie występowania braków danych, żeby wiedzieć gdzie w regułach musimy dopuśćić wystapowanie NA
miss_var_summary(dane_gdansk)
# reguly 
rules_hard <- validator(

  squareMeters > 0,
  squareMeters <= 250,

  rooms >= 1,
  rooms <= 8,         

  squareMeters >= rooms * 8,      
  squareMeters <= rooms * 40,     

  floor >= 0 | is.na(floor),     
  floorCount >= 1 | is.na(floorCount),
  floor <= floorCount | is.na(floor) | is.na(floorCount),

  buildYear >= 1850 | is.na(buildYear),
  buildYear <= 2025 | is.na(buildYear),
  
  centreDistance >= 0,
  schoolDistance >= 0 | is.na(schoolDistance),
  clinicDistance >= 0 | is.na(clinicDistance),
  postOfficeDistance >= 0 | is.na(postOfficeDistance),
  kindergartenDistance >= 0 | is.na(kindergartenDistance),
  restaurantDistance >= 0 | is.na(restaurantDistance),
  collegeDistance >= 0 | is.na(collegeDistance),
  pharmacyDistance >= 0 | is.na(pharmacyDistance),

  centreDistance <= 20,
  schoolDistance <= 10 | is.na(schoolDistance),
  clinicDistance <= 10 | is.na(clinicDistance),
  postOfficeDistance <= 10 | is.na(postOfficeDistance),
  kindergartenDistance <= 10 | is.na(kindergartenDistance),
  restaurantDistance <= 10 | is.na(restaurantDistance),
  collegeDistance <= 15 | is.na(collegeDistance),
  pharmacyDistance <= 10 | is.na(pharmacyDistance),

  poiCount >= 0,
  poiCount <= 300,               

  type %in% c("tenement","blockOfFlats","apartmentBuilding") | is.na(type),
  ownership %in% c("condominium","cooperative"),

  hasParkingSpace %in% c("yes","no"),
  hasBalcony %in% c("yes","no"),
  hasElevator %in% c("yes","no") | is.na(hasElevator),
  hasSecurity %in% c("yes","no"),
  hasStorageRoom %in% c("yes","no"),

  price > 0,
  price / squareMeters >= 8000,
  price / squareMeters <= 35000
)
out_hard <- confront(dane_gdansk, rules_hard)
summary(out_hard)
# #dane_gdansk%>%
# #  summarise(n = sum(!is.na(floor) & !is.na(floorCount) & floor > floorCount))
# dane_gdansk <- dane_gdansk %>%
#     mutate(floor = if_else(!is.na(floor) & !is.na(floorCount) & floor > floorCount,
#                          NA, floor))
out <- confront(dane_gdansk, rules_hard)
summary(out)
summary(out_hard)$fails

rules_soft <- validator(

  !(buildYear < 1945 & floorCount > 7) | is.na(buildYear) | is.na(floorCount),
  !(floor >= 5 & buildYear >= 1995 & hasElevator == "no") | is.na(floor) | is.na(buildYear) | is.na(hasElevator),
  !(squareMeters < 35 & rooms >= 3),
  !(squareMeters > 80 & rooms == 1)
)
out_soft <- confront(dane_gdansk, rules_soft)
summary(out_soft)
summary(out_soft)$fails


# Dla zmiennych, w których nie występowały braki danych, nie uwzględniano warunku is.na(). Dla pozostałych zmiennych braki danych pozostawiono i traktowano jako dopuszczalne
```

dentyfikacja outlierów metodą IQR

```{r echo=FALSE}
# wybór zmiennych numerycznych
num_vars <- dane_gdansk %>% select(where(is.numeric))

iqr_outliers <- num_vars %>%
  summarise(across(
    everything(),
    ~ {
      q1 <- quantile(.x, 0.25, na.rm = TRUE)
      q3 <- quantile(.x, 0.75, na.rm = TRUE)
      iqr <- IQR(.x, na.rm = TRUE)
      mean(.x < (q1 - 1.5 * iqr) | .x > (q3 + 1.5 * iqr), na.rm = TRUE) * 100
    }
  )) %>%
  pivot_longer(
    everything(),
    names_to = "variable",
    values_to = "pct_outliers"
  ) %>%
  arrange(desc(pct_outliers))

iqr_outliers %>%
  mutate(variable = label_vars(variable))%>%
  mutate(pct_outliers = round(pct_outliers, 2)) %>%
  filter(pct_outliers!= 0)%>%
  gt() %>%
  tab_header(
    title = "Identyfikacja wartości odstających (IQR)",
    subtitle = "Odsetek obserwacji poza granicami Q1 − 1.5·IQR oraz Q3 + 1.5·IQR"
  ) %>%
  cols_label(
    variable = "Zmienna",
    pct_outliers = "% obserwacji odstających"
  )
top_vars <- iqr_outliers %>%
  filter(pct_outliers > 0) %>%
  slice_max(pct_outliers, n = 4) %>%
  pull(variable)

d_top <- dane_gdansk %>%
  select(all_of(top_vars)) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "value")%>%
filter(value != 0)
ggplot(d_top, aes(y = value)) +
  geom_boxplot(outlier.colour = "red", outlier.alpha = 0.6) +
  facet_wrap(~ variable, scales = "free_y", labeller = as_labeller(var_labels), ncol = 2) +
  theme_minimal() +
  labs(
    title = "Wykresy pudełkowe zmiennych z najwyższym udziałem outlierów (IQR)",
    x = NULL,
    y = "Wartość"
  )

```

2.1 Braki danych W celu określenia mechanizmu braków danych przeprowadzono test Little MCAR. Wynik testu był istotny statystycznie (χ² = 2374.25, df = 569, p \< 0.001), co pozwala odrzucić hipotezę o całkowicie losowym charakterze braków (MCAR). Oznacza to, że zmienne w zbiorze zawierają braki zależne od innych informacji (MAR) lub od wartości samej zmiennej (MNAR). Braki danych nie mają więc charakteru losowego i wymagają zastosowania zaawansowanej metody imputacji, takiej jak MICE. floor, rokbudowy, czy jest winda, odleglosc od uni Z brakami danych do uzupelnienia. Type i reszta zostaje z brakami danych, bo nie oplaca sie -\> jak to uzasadnić?

mice dla zmiennych numerycznych buduje model liniowy, dla kategorzycznych logitowy

```{r}
mcar_test(dane_gdansk)
gg_miss_var(dane_gdansk)
vis_miss(dane_gdansk)
gg_miss_upset(dane_gdansk)
missing_pattern(dane_gdansk)
```

W zbiorze danych przeprowadzono analizę braków, której celem było określenie ich zakresu, struktury oraz mechanizmu powstawania. Łączny odsetek braków wyniósł około 3%, jednak nie były one równomiernie rozłożone między zmiennymi. Najwięcej braków odnotowano w zmiennych type, floor oraz buildYear, co wskazuje, że dotyczą one głównie informacji opisujących cechy budynku. Pozostałe zmienne charakteryzowały się znikomym poziomem braków.

Wizualizacje braków, w tym mapy ciepła oraz wykresy typu vis_miss i UpSet Plot, wykazały istnienie wyraźnych wzorców współwystępowania brakujących wartości, co sugeruje, że nie mają one charakteru przypadkowego.

Ze względu na nielosowy charakter braków oraz ich koncentrację w wybranych zmiennych, do uzupełnienia danych zastosowano metodę imputacji wielokrotnej MICE. Metoda ta pozwala odtworzyć brakujące wartości w sposób zgodny z zależnościami występującymi w zbiorze, ograniczając ryzyko zniekształcenia wyników dalszej analizy. Zmienne o minimalnej liczbie braków pozostawiono bez imputacji, gdyż ich wpływ na modele jest pomijalny. Dzięki przeprowadzonej imputacji uzyskano kompletny i spójny zbiór danych, odpowiedni do kolejnych etapów modelowania.

ggmice

```{r}
methods <- make.method(dane_clean)
methods[] <- ""

methods["floor"]           <- "pmm"    
methods["buildYear"]       <- "pmm"
methods["hasElevator"]     <- "logreg"
methods["collegeDistance"] <- "pmm"
   
pred <- make.predictorMatrix(dane_clean)
pred[,] <- 0   

pred_floor <- c("floorCount", "rooms", "squareMeters",
                "buildYear", "hasElevator",
                "centreDistance", "poiCount")

pred["floor", pred_floor] <- 1

pred[, "type"] <- 0
pred["type", ] <- 0

set.seed(123)
imp <- mice(
  dane_clean,
  method = methods,
  predictorMatrix = pred,
  m = 5,
  maxit = 10,
  ridge = 1e-5
)

dane_imputed <- complete(imp, 1)

ggplot()+
  geom_miss_point(data = dane_gdansk, aes(x = floor, y = buildYear , color = "red"))
plot(imp)



hist(dane_clean$floor)
densityplot(imp, ~ floor)
xyplot(imp, floor ~ buildYear)
summary(complete(imp, "long"))
# dDIDAĆ STRIP LOT, PRZYNAIMNIEJ SPRAWDZIC O CO CHODZI 
```

W zbiorze danych imputacją objęto wyłącznie zmienne z udziałem braków przekraczającym 3%, z wyłączeniem zmiennej type, której zgodnie z zaleceniem prowadzącego nie imputowano. Ostatecznie uzupełniono cztery zmienne: floor, buildYear, hasElevator oraz collegeDistance.

Typy zmiennych zostały odpowiednio przygotowane: hasElevator oraz type zadeklarowano jako zmienne kategoryczne (factor), natomiast floor pozostawiono jako zmienną liczbową. Jest to istotne, ponieważ pakiet mice dobiera metodę imputacji na podstawie typu danych.

Do imputacji zmiennych liczbowych (floor, buildYear, collegeDistance) zastosowano metodę PMM (Predictive Mean Matching), która dobiera brakujące wartości z rzeczywistych obserwacji o podobnych przewidywanych wartościach, dzięki czemu zachowuje naturalny rozkład danych. Binarną zmienną hasElevator imputowano metodą regresji logistycznej (logreg), co gwarantuje pozostanie wartości w zakresie 0/1.

W celu zwiększenia stabilności imputacji ograniczono liczbę predyktorów używanych do przewidywania zmiennej floor jedynie do zmiennych merytorycznie powiązanych (m.in. floorCount, rooms, squareMeters, buildYear, centreDistance, poiCount). Dodatkowo zmienną type wyłączono z macierzy predyktorów, aby nie wpływała ona na modele imputacyjne ze względu na własne braki. Zastosowano również niewielką regularyzację (ridge = 1e−5), co zapobiegało problemom numerycznym.

Imputację przeprowadzono funkcją mice() z pięcioma iteracjami kompletnego zestawu danych (m = 5). Kompletny zbiór uzyskano poleceniem complete(imp, 1). Zastosowane podejście pozwoliło uzyskać realistyczne i statystycznie poprawne uzupełnienie braków danych, zgodnie z wytycznymi prowadzącego

Zakresy wartości są racjonalne — nie pojawiły się wartości nierealne (np. ujemne odległości, nierealne lata budowy czy zerowe piętra). Cena nieruchomości również mieści się w realnym zakresie obserwowanym w danych wejściowych. Wszystko to potwierdza, że imputacja została wykonana poprawnie, a dane mogą być bezpiecznie wykorzystane w dalszej analizie ekonometrycznej i modelowaniu.

rozdzial 2 sprawdzanie spojnosci danych srtrip plot dla danych po imputacji

```{r}
# Dla zmiennych, w których nie występowały braki danych, nie uwzględniano warunku is.na(). Dla pozostałych zmiennych braki danych pozostawiono i traktowano jako dopuszczalne
```

```{r}
# bledy (wstawiamy NA), 
# radzenie sobie z bledami
# dane gotowe do analizy

mcar_test(dane_clean)
miss_var_summary(dane_clean)
str(dane_clean) 
#zmianiamy reste zmiennych na factor, zeby potem mozna bylo wykorzystywac logit, trrzeba zapytac w ktoeym momencie to najlepije zrobic prze czy po imputacji
dane_clean<- dane_clean%>%
  mutate(across(where(is.character), as.factor)) 
```

dane jakosciowe Rozdzial X : analiza opisowa i wizualizacja zmiennych jakościowych Wykresy i statystyki opisowe do świąt

```{r}
# Wykresy zmiennych ilościowych 
# a) Rozkład cen mieszkań, czy trzeb pokazac takze w skali log?

ggplot(dane_clean, aes(x = price)) +
  geom_histogram(bins = 40, fill = "#4292c6", color = "white") +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Rozkład cen mieszkań",
    x = "Cena (PLN)",
    y = "Liczba ofert"
  ) +
  theme_minimal()
# b)cena a metraż
ggplot(dane_clean, aes(x = squareMeters, y = price)) +
  geom_point(alpha = 0.4, color = "#2b8cbe") +
  geom_smooth(method = "lm", se = FALSE, color = "#d95f0e") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Zależność ceny od metrażu",
    x = "Metraż (m²)",
    y = "Cena (PLN)"
  ) +
  theme_minimal()
# c) cena za metrz kwadratowy a odległość od ....
library(dplyr)
df <- dane_clean %>%
  mutate(price_m2 = price / squareMeters)

ggplot(df, aes(x = centreDistance, y = price_m2)) +
  geom_point(alpha = 0.4, color = "#74a9cf") +
  geom_smooth(method = "loess", color = "red") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Cena za m² a odległość od centrum",
    x = "Odległość od centrum (km)",
    y = "Cena za m² (PLN)"
  ) +
  theme_minimal()
# d) liczba pokoi a cena
ggplot(dane_clean, aes(x = factor(rooms), y = price)) +
  geom_boxplot(fill = "#9ecae1") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Cena mieszkań a liczba pokoi",
    x = "Liczba pokoi",
    y = "Cena (PLN)"
  ) +
  theme_minimal()

# wykresy zmiennych jakościowych 
# a) typ mieszkania w porównaniu do ilości ? moze zamienic na cos ineego -> BOO A DUŻO BRAKÓW BYŁO
ggplot(df, aes(x = type)) +
  geom_bar(fill = "#6baed6") +
  labs(
    title = "Liczba ofert według typu mieszkania",
    x = "Typ",
    y = "Liczba ofert"
  ) +
  theme_minimal() 
# b) porównanie do ceny 

# d) balkon a cena 
ggplot(df, aes(x = hasBalcony, y = price)) +
  geom_boxplot(fill = "#a1d99b") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Wpływ balkonu na cenę mieszkania",
    x = "Balkon",
    y = "Cena (PLN)"
  ) +
  theme_minimal()
```

```{r summarytools_print, results='asis', echo=FALSE}


print(dfSummary(dane_clean, style = "grid"), method = "render", theme = "light")

descr(dane_clean %>% select(where(is.numeric)))   # tylko numeryczne
freq(dane_clean %>% select(where(is.factor))) 

# statystyki opisowe  dla zmiennych ilosciowych
summary(dane_clean %>% select(where(is.numeric)))
summary(dane_clean %>% select(where(is.factor)))


num_vars <- dane_clean %>%
  select(where(is.numeric))
cor_matrix <- cor(
  num_vars,
  use = "pairwise.complete.obs",
  method = "pearson"
)

round(cor_matrix, 2)
corrplot(cor_matrix, method = "color", type = "upper")

num_vars <- dane_clean %>%
  select(
    price,
    squareMeters,
    rooms,
    floor,
    buildYear,
    centreDistance,
    schoolDistance,
    clinicDistance,
    restaurantDistance
  )

cor_matrix <- cor(
  num_vars,
  use = "pairwise.complete.obs",
  method = "spearman"
)

round(cor_matrix, 2)


# statystyki opisowe  dla zmiennych jakosciowych

```

```{r}
# testy statystyczne 
library(ggstatsplot)

ggbetweenstats(
  data = dane_clean,
  x = hasBalcony,
  y = price,
  title = "Wpływ balkonu na cenę mieszkania",
  xlab = "Balkon",
  ylab = "Cena (PLN)"
) 
# ilościowe

# jajosciowe 

```
